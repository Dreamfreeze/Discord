class RoleModeration(Cog):

    """
        #  Author : krigjo25
        #  Date :   

        Commands for Moderators with manage_role

        #   Create a role
        #   Delete a role
        #   modify a role
    """

    def __init__(self, bot):

        self.bot = bot
        self.embed = Embed()
        self.now = datetime.datetime.now()

        return

    #   Slash command group
    role = d.SlashCommandGroup(name = "role", description = "Role mananger", default_member_permissions = d.Permissions(manage_roles = True))

    #@role.commend()
    async def create(): pass

    @role.command() # delete a role
    async def delete(self, ctx, role ):

        """
            1   Checking if there is any channels called 'moderationlog'
            2   Ask the user for comfirmation before removing the role

        """

        #   Fetch role and channel
        role = utils.get(ctx.guild.roles, name= role)
        ch = utils.get(ctx.guild.channels, name='auditlog')

        try:
            if not role : raise Exception(f"\"{role}\" does not exists")
            elif not ch : raise Exception("audit channel does not exist")

        except Exception as e:

            self.embed.title = "An Exception Occured"
            self.embed.description = f'{e}, Try again...'
            await ctx.send(embed = self.embed)

            #   Clear some memory
            del role, ch
            return

        else:

            #   Prepare, send & clean up the embed message
            self.embed.title = f'Removing {role} role'
            self.embed.description = f'Sometimes we do not do what we do something stupid? type in the role to delete the role'

            await ctx.send(embed=self.embed)

            self.embed.clear_fields()

            #   Confirm the action
            response = await self.bot.wait_for('message', timeout=60.0)
            response = str(response.content)

            if response == role:
                #   Prepare the embed message and delete & role
                self.embed.title = f'{role} role, has been removed from the server'
                await response.delete()

            else: self.embed.title = f'Role removal cancelled'

        #   Send & clean up the embed message
        self.embed.color = Colour.dark_red()
        await ch.send(embed=self.embed)

        del role, ch, response

        return
 
    @role.command()# remove a member from a role
    async def demote(self, ctx, member:d.Member, role, *, reason=None ):

        """
            1   Checking if there is any channels called 'auditlog'
            2   When the command is invoked, ask the user for a confirmation
            3   Remove the user from the role

        """

        #   Initializing variables
        role = utils.get(ctx.guild.roles, name=f'{role}')
        ch = utils.get(ctx.guild.channels, name='auditlog')

        #   Prepare, Send & Clean up embed
        try: 
            if not role : raise Exception(f"Role \"{role}\" Not found")
        except Exception as e: 

            self.embed.color = Colour.dark_red()
            self.embed.title = 'An Exception Occured'
            self.embed.description = f"{e}, try again."
            await ctx.send(embed = self.embed)

        else:

            self.embed.color = Colour.dark_red()
            self.embed.title = f'removing {member} from {role}'
            self.embed.description = f'Type in the name if you really want to remove the person from the role.'

            await ctx.send(embed=self.embed)

        #   Retrieve the confirmation from the user
        response = await self.bot.wait_for('message')
        response = str(response.content).lower()

        if response in member:

            #  Prepare, remove, send & Clean up
            self.embed.color = Colour.dark_red()
            self.embed.title = f'{member} has been removed from {role} by {ctx.author} due to {reason} '

            await member.remove_roles(role)

        else:

            #   Prepare Send & Clean up
            self.embed = Embed(color=Colour.dark_red())
            self.embed.title = f'Role removal has been cancelled'

        self.embed.description=''
        await ch.send(embed=self.embed)


        return self.embed

    #   Set Role
    @role.command() # set a role
    async def set(self, ctx, member:d.Member, role, *, reason= None):

        #   Fetch roles and channel

        role = utils.get(ctx.guild.roles, name=f'{role}')
        ch = utils.get(ctx.guild.channels, name='auditlog')

        try :
            if not role: raise Exception("Role does not exist")
            elif not ch: raise Exception("auditlog channel does not exist")

        except Exception as e:

            self.embed.title = "An Exception Occured"
            self.embed.description = f"{e}, try again"
            await ctx.send(embed = self.embed)

            del role, ch
            return
        else:
            #   Prepare, Send & Clean up embed
            self.embed.color = Colour.dark_red()
            self.embed.title = f'removing {member} from {role}'
            self.embed.description = f'Type in **{member}** to set the member as {role}?'

            await ctx.send(embed=self.embed)

        #   Retrieve the confirmation from the user
        response = await self.bot.wait_for('message')
        response = str(response.content).lower()

        if response in member:

            #  Prepare, remove, send & Clean up
            self.embed.color = Colour.dark_red()
            self.embed.title = f'{member} has been added to {role} by {ctx.author}'
            self.embed.description = f"{reason}"

            await member.add_roles(role)


    #   Change Color for the role
    @role.command()
    async def modify(self, ctx, role, *, reason= None):

        #   Initializing classes
        perm = RolePermission

        #   Fetch channel and role
        ch = utils.get(ctx.guild.channels, name= 'auditlog')
        role = utils.get(ctx.guild.roles, name = f'{role}')
        color = ["Dark Purple", "Dark Red", "Dark Blue", "Purple", "Red", "Blue"]

        try:

            if not role: raise Exception("Role does not exists")
            if not ch: raise Exception("audit channel does not exists")

        except Exception as e:

            self.embed.color = Colour.dark_red()
            self.embed.title = 'An Exception Occured'
            self.embed.description = f'{e}, try again'
        
            await ctx.send(embed=self.embed)

            del ch, role, color, dc
            return

        else: 
            #   Prepare, send & Clean up
            self.embed.title = f'Choosing role Color'
            self.embed.description = f'Would you like to change colors of {role}? type in a title or **x** to exit '
            self.embed.add_field(name = 'Dark Purple', value = 'Dark Purple color for role ')
            self.embed.add_field(name = 'Purple', value = 'Purple color for role')
            self.embed.add_field(name = 'Dark Red', value = 'Dark red color for role')
            self.embed.add_field(name = 'Red', value = 'Red color for role')
            self.embed.add_field(name = 'Dark Blue', value = 'Dark Blue color for role')
            self.embed.add_field(name = 'Blue', value = 'Blue color for role')

            await ctx.send(embed=self.embed)
            self.embed.clear_fields()

            response = await self.bot.wait_for('message', timeout=30)
            response = str(response.content).lower().replace(" ", "")

            if response in color: color = dc.RoleColours(response)
            else: color=Colour.default()

            await ctx.guild.edit_role(name=f'{role}', color = color, reason = f'{reason}')
            
            self.embed.title = f"@{role}'s colour has changed into {response} by {ctx.author.name}"

            await ch.send(embed=self.embed)
            self.embed.clear_fields()

            #   Clear some memory
            del response, color, role
            del ch, dc
        return

    @role.before_invoke
    async def check_channel(self, ctx: d.ApplicationContext):

        channel = []
        ch = ["auditlog", "report", "support"]

        try :
            for i in ch:
                if utils.utils.get(ctx.guild.text_channels, name = i): return 


        except TypeError as e: print(e)
        else:

            #   Creating a channel
            perms = {ctx.guild.default_role:d.PermissionOverwrite(view_channel=False)}

            for i in ch:

                #   Prepare and send embeded message
                self.embed.color = Colour.dark_red()
                self.embed.title = f'Auto Generated Channel'



                match i:

                    case "auditlog": 
                        self.embed.description = "Created to have easy accsess to bot commands used by admin / moderator"
                        i = await ctx.guild.create_text_channel(i, overwrites=perms)

                    case "report": 
                        self.embed.description = "Member report channel"
                        i = await ctx.guild.create_text_channel(i, overwrites=perms)

                    case "support": 
                        self.embed.description = "Member support channel"
                        i = await ctx.guild.create_text_channel(i, overwrites=perms)

                self.embed.timestamp = datetime.datetime.now()
                await i.send(embed=self.embed)
    
        #   Clear some memory
        del perms, ch, channel
        self.embed.description =""

        return

    @role.after_invoke
    async def clear_memory(self, ctx: d.ApplicationContext):

        #   Clear some Memory
        self.embed.clear_fields()
        self.embed.remove_image()
        self.embed.remove_author()
        self.embed.remove_footer()
        self.embed.remove_thumbnail()
        self.embed.color = Colour.dark_purple()
        self.embed.description = ""

        #   Responding to discord
        await ctx.respond("Responding to a command")
        asyncio.sleep(1)
        await ctx.delete()
        return

class MiscModeration(Cog):

    """
        #  Author : krigjo25
        #  Date :   

        Miscerillious commands

        #   Create a role
        #   Delete a role
        #   modify a role
    """
        #   Channel moderation
        #   Commands for Moderators with manage_channels & manage_messages

    def __init__(self, bot):

        self.bot = bot
        self.embed = Embed()
        self.now = datetime.datetime.now().strftime('%H:%M, %d.%b - %y')

        return

    #   Slash command group
    misc = d.SlashCommandGroup(name = "misc", description = "misc moderator commands", default_member_permissions = d.Permissions(manage_channels = True))

    @misc.command()
    async def polls(self, ctx, title, ch):

        """

            #   Creating a poll with default two values to choose from
            #   Using reaction to vote
            #   Title of the poll, how many options and Questions

        """

        pass

    @misc.command()
    async def serverbots(self, ctx):

        #   Fetching members
        for member in ctx.guild.members:

            #   Add emoji to status
            match member.status:
                case "idle": status = ":dash:"
                case "dnd": status = ":technologist:"
                case "Online": status = ":heart_on_fire:"
                case "offline": status = ":no:"

            #   Fetch user nick
            if str(member.nick) == None: nick = ''
            else: nick = f'Nick : {member.nick}\n'

            if member.bot == True: self.embed.add_field(name=f'{member.name} #{member.discriminator}',value=f'{nick}\n Status : {status}', inline=False)

        self.embed.title = 'Server Bots'
        self.embed.description = 'List of members'
        
        await ctx.send(embed = self.embed)
        
        self.embed.clear_fields()

class MemberModeration(Cog):

    """
        #  Author : krigjo25
        #  Date :   

        Commands for Moderators with moderate members

        #   Warn a member
        #   Sush a member
        #   lift a member
        #   kick a member
    """
    def __init__(self, bot):

        self.bot = bot
        self.now = datetime.datetime.now().strftime("%a, %d.%b-%y")
        self.embed = Embed()

        return

    member = d.SlashCommandGroup(name = "member", description = "Member mananger", default_member_permissions = d.Permissions(moderate_members = True))

    @member.command()
    async def warn(self, ctx, member:d.Member, *, reason=None):

        #   Fetch the channel log
        chlog = utils.utils.get(ctx.guild.channels, name='auditlog')

        try:
            if member == ctx.author: raise Exception("Can not warn your self")
            elif reason == None: raise Exception("Please provide a reason for the warn")

        except Exception as e :

            self.embed.color = Colour.dark_red()
            self.embed.title = "An Exception Occured"
            self.embed.description =f"{e}, Try again !"

            del chlog, member, reason

            return

        else:

            #   Prepare the embed message
            self.embed.color = Colour.dark_red()
            self.embed.description = f'*{reason}*.'
            self.embed.timestamp = datetime.datetime.now()
            self.embed.title = f'**{member}** has been warned by {ctx.author.name} Date: {self.now}'

            #   Message the user about the warn
            message = f'Greetings **{member}**.\n You recieve this Notification, because you have been warned by **{ctx.author}**.\n\n Due to :\n *{reason}*\n\nPlease read and follow the suggested guidelines for behavior in our disocrd channel'
            await member.send(message)

        await chlog.send(embed=self.embed)

        #   Clear some memory
        del message, reason, chlog
        del member

        return

   #   Mute Members
    @member.command()
    async def sush(self, ctx, member:d.Member, time=None, *, reason=None):

        """
            #   Fetch the channel
            #   Check if "time" argument is digits
            #   #   Set the time as int if it is a digit
            #   Check if the channel exists
            #   Check if there is a reason for unmute
            #   Check if the time is less than 1 week
            #   Check if the author is the member
            #   Calculate the time
            #   Prepare and messages
            #   timeout and send the message
        """

        #   Fetching the channel
        role = utils.get(ctx.guild.roles, name ='Sushed')
        ch = utils.get(ctx.guild.channels, name='auditlog')

        try:

            #   Checking if the selected member is the command invoker
            if member == ctx.author: raise Exception(f"Could not sush your self.")
            elif len(time) < 2: raise Exception(f"{time}s / m / h / d)")
            elif int(time[0]) > 604800: raise Exception(f' Could not sush **{member}** due to a limitation for 1w')
            elif not ch : raise Exception("Auditlog does not exists")
            elif reason == None: raise Exception(f" Could not sush **{member}** due to there were no reason to mute the member")

        except Exception as e: 

            self.embed.color = Colour.dark_red()
            self.embed.title = "An Exception Occured"
            self.embed.description = f"{e}"
            await ctx.send(embed = self.embed)

            #   Clear some memory
            del time, ch, reason, member

            return

        else:

            #   Calculating the time
            time = hf.parse_timespan(time)

            #   Prepare, send & Clean up embed
            self.embed.color = Colour.dark_red()
            self.embed.title = f"**{member.name}** has been sushed by {ctx.author.name} for {time} seconds. Date : {self.now}"
            self.embed.description = f"*{reason}*."
            await ch.send(embed=self.embed)

            #   Prepare and send the member, the message and sush the member
            await member.add_roles(role)
            await member.send(f"""Greetings, **{member.name}**.\nYou recieve this message, because server moderator {ctx.author.name} gave you an timeout for **{datetime.timedelta(seconds=time)}**.\nYou will not be able to use the {ctx.guild}'s channels, during this given time.\nThe reason for this intervention is\n*{reason}*""")
            await member.timeout(until = d.utils.utcnow() + datetime.timedelta(seconds=time), reason = reason)

        #   Clear some memory
        del member, reason, time
        del ch

        return

    @member.command()
    async def lift(self, ctx, member:d.Member):

        """
            #   Fetching the channel and role
            #   Checking for exceptions
            #   Remove the member role
            4   send the selected member a message
        """

        #   Fetch channel and role
        ch = utils.get(ctx.guild.channels, name='auditlog')
        role = utils.get(ctx.guild.roles, name ='Sushed')

        try :
            #   Check for exceptions
            if not ch: raise Exception("Auditlog channel does not exist")
            if not role: raise Exception("@Sushed role does not exit")

        except Exception as e:

            self.embed.description = f"{e}"
            self.embed.color = Colour.dark_red()
            self.embed.title = "An Exception Occured"
            await ctx.send(embed = self.embed)

            del ch, role
            return

        else:

            #   Prepare & send embed message
            self.embed.color = Colour.dark_red()
            self.embed.title = f'Sush Lifted for {member}'
            self.embed.timestamp = datetime.datetime.now()
            self.embed.description = f"by **{ctx.author.name}**\n Date: {self.now} User has been notified by a direct message."
        
        await ch.send(embed= self.embed)

        #   Removing role, timeout & Notify the user
        await member.remove_roles(role)
        await member.timeout(until=None, reason="unmuted")
        await member.send(f'Greetings **{member}**.\n\n The sush has been lifted you can now use {ctx.guild}')

        #   Clear some memory
        del role, ch, member
        return

    #   Kick Members
    @member.command()
    async def kick(self, ctx, member:d.Member, *, reason=None):

        """
            #   Fetching the auditlog channel
            #   Checks for exceptions
            #   Prepare the embed message
            #   Sending the member notification for the kick
            #   Kicking the member
        """

        #   Fetching the channel
        ch = utils.get(ctx.guild.channels, name='auditlog')

        try :

            if member == ctx.author: raise Exception("Can not kick your self")
            if reason == None: raise Exception(f"**{ctx.author.name}** Provide a reason to kick **{member.name}**")
            if not ch : raise Exception("There is no channel named auditlog")

        except Exception as e :

            self.embed.title = "An Exception Occured"
            self.embed.description = f"{e}, try again."
            self.embed.color = Colour.dark_red()
            await ctx.send(embed=self.embed)

            #   Clear some memory
            del ch, reason, member

        else:

            #   Prepare embed
            self.embed.color = Colour.dark_red()
            self.embed.description = f' *{reason}*.'
            self.embed.timestamp = datetime.datetime.now()
            self.embed.title = f'**{member}** has been kicked from the server by {ctx.author.name} Date : {self.now}'

            #   Creating a message to the user, send it to his DM, then kick
            await member.send(f"Greetings **{member}**.\nYou recieve this message, because moderator {ctx.author.name} kicked you from {ctx.guild.name}\nDue to :\n *{reason}*")
            await member.kick(reason=reason)

        #   Send & Clean up embed
        await ch.send(embed=self.embed)

        return

    #   Members
    #   Warn a member
    #   Timeout a member
    #   Lift a member
    #   Kick a member
    #   decorators

